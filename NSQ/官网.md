



 [官网地址]( https://nsq.io/overview/quick_start.html )

# OVERVIEW 

## QUICK START

1. 安装NSQ， [地址]( https://nsq.io/deployment/installing.html )

2. in one shell, start `nsqlookupd`:

   ```
   $ nsqlookupd
   ```

3. in another shell, start `nsqd`:

   ```
   $ nsqd --lookupd-tcp-address=127.0.0.1:4160
   ```

4. in another shell, start `nsqadmin`:

   ```
   $ nsqadmin --lookupd-http-address=127.0.0.1:4161
   ```

5. publish an initial message (creates the topic in the cluster, too):

   ```
   $ curl -d 'hello world 1' 'http://127.0.0.1:4151/pub?topic=test'
   ```

6. finally, in another shell, start `nsq_to_file`:

   ```
   $ nsq_to_file --topic=test --output-dir=/tmp --lookupd-http-address=127.0.0.1:4161
   ```

7. publish more messages to `nsqd`:

   ```
   $ curl -d 'hello world 2' 'http://127.0.0.1:4151/pub?topic=test'
   $ curl -d 'hello world 3' 'http://127.0.0.1:4151/pub?topic=test'
   ```

8. to verify things worked as expected, in a web browser open `http://127.0.0.1:4171/` to view the `nsqadmin` UI and see statistics. Also, check the contents of the log files (`test.*.log`) written to `/tmp`.

## FEATURES & GUARANTEES

 NSQ是一个实时分布式消息传递平台

1. Features

   1.  支持没有SPOF (Single Point Of Failure, 单点故障) 的分布式拓扑 
   2.  水平扩展 (没有brokers ，无缝地向集群添加更多节点) 
   3. 基于消息传递的低延迟push
   4.  组合负载平衡和多播样式的消息路由 
   5.  擅长面向流(高吞吐量)和面向job(低吞吐量)的工作负载 
   6.  主要在内存中(高水位标记之外的消息透明地保存在磁盘上) 
   7.  运行时发现服务，供消费者者查找生产者([nsqlookupd](https://github.com/nsqio/nsq/tree/master/nsqlookupd/README.md) ) 
   8.  传输层安全性(TLS) 
   9.  data format agnostic 
   10.  很少的依赖项(易于部署)和一个健全的、有限的默认配置
   11.  简单的TCP协议支持任何语言的客户端库 
   12. 用于统计、管理操作和生产者的HTTP接口(发布消息不需要客户端库)  
   13.  与``statsd`集成，实现实时检测 
   14.  健壮的集群管理接口(nsqadmin) 

2. ### Guarantees

   1.  消息**不是**持久的(默认情况下) 
   2.  消息至少传递一次 
   3.  接收到的消息是无序的 
   4.  消费者**最终**会找到所有的主题生产者 

3. FAQ

   1. #### Deployment

      1.  nsqd的推荐拓扑是什么?
      2.  为什么`nsqlookupd`不能被生产者用来查找发布到哪里? 
      3.   我只想使用`nsqd`作为单个节点上的工作队列，这是一个合适的使用场景吗? 
      4.   我应该运行多少个nsqlookupd ? 
      
   2. #### Publishing
   
      1.  我需要一个客户端库来发布消息吗? 
   
      2.  为什么要强制客户端处理对TCP协议的PUB和MPUB命令的响应? 
   
      3.  When can a `PUB` or `MPUB` fail? 
   
         1. The topic name is not formatted correctly (to character/length restrictions). See the [topic and channel name spec](https://nsq.io/clients/tcp_protocol_spec.html#notes).
         2. The message is too large (this limit is exposed as a parameter to `nsqd`).
         3. The topic is in the middle of being deleted.
         4. `nsqd` is in the middle of cleanly exiting.
         5. Any client connection-related failures during the publish.
   
         (1) and (2) should be considered programming errors. (3) and (4) are rare and (5) is a natural part of any TCP based protocol.
   
      4.  How can I mitigate scenario (3) above?
   
   3. #### Design and Theory
   
      1.  如何为主题和通道命名? 
   
         1. A topic name should describe the *data in the stream*.
         2. A channel name should describe the *work performed* by its consumers.
         3. For example, good topic names are `encodes`, `decodes`, `api_requests`, `page_views` and good channel names are `archive`, `analytics_increment`, `spam_analysis`.
   
      2.  单个nsqd可以支持的主题和通道的数量有限制吗? 
   
          没有内置的限制。它只受运行nsqd的主机的内存和CPU的限制 
   
      3.  如何向集群发布/t通告新主题?
   
          第一个`PUB`或`SUB`将在nsqd上创建主题。然后，主题元数据将传播到配置的`nsqlookupd`。其他读者将通过定期查询`nsqlookupd`来发现这个主题。  
   
      4.  NSQ可以做RPC吗? 
   
   5. #### pynsq Specific
   
## DESIGN

NSQ是simplequeue (simplehttp的一部分)的继承者，因此被设计成: 

	-  支持高可用性和消除SPOFs的拓扑 
	-   解决对更强的消息传递保证的需求 
	-   限制单个进程的内存占用(通过将一些消息持久化到磁盘) 
	-   极大地简化了生产者和消费者的配置需求 
	-   提供一个简单的升级路径 
	-   提供一个简单的升级路径 

###  Simplifying Configuration and Administration

1. 一个 `nsqd` 实例被设计成同时处理多个数据流。streams被称为`topics`, 并且一个 topic有一个或多个`channels`。每个channel接收一个主题所有消息的一个备份。在实践中，一个channel  映射到使用主题的下游服务。 

2.  topics 和 channel 不是预先配置的。

   topics被首次创建当发生如下情况：

   1. publish 到一个命名topic
   2.  subscribe指定topic的channel。 

   channel 被首次创建当订阅指定的频道。 

3.  topic 和 channel 的所有缓冲数据都是相互独立的，这样可以防止速度较慢的 consumer  造成其他channel 的积压(在topic 级别也是如此)。 

4. 一个 channel 可以有 (通常也确实有) 多个客户端连接。假设所有已连接的客户端处于可接收消息的状态，那么每条消息将被随机分发给其中一个客户端

   ![f1434dc8-6029-11e3-8a66-18ca4ea10aca](F:\PersonPorject\book-notes\NSQ\img\f1434dc8-6029-11e3-8a66-18ca4ea10aca.gif)

5. topic -> 角度来看， 消息是多播的(每个通道接收到一个主题所有消息的一个副本)； 但是从channel -> consumers角度来看，每个消费者只接收到了那个通道一部分消息

6. NSQ 包含了一个辅助应用， `nsqlookup`，其提供了目录服务，该目录服务支持consumer查询可以提供他们想要订阅的topic的 `nsqd`实例的地址。 在配置方面，这将 producer 与 consumer 分离(它们都单独地只需要知道在哪里联系公共的 nsqlookupd 实例，而不需要相互联系)，从而降低了复杂性和维护。 

7. 从较低的基本来看， `nsqd`和`nsqlookupd`保护着一个 TCP 长连接， `nsqd`通过该连接定期推送自己的状态到 `nsqlookupd`。 此数据用于通知`nsqlookupd`将向consumer提供哪些`nsqd`地址。  对于消费者来说，有一个公开的HTTP endpoint `/lookup`用于轮询。 

8.  要引入某个主题的新的不同消费者，只需启动一个NSQ客户端，该客户端使用`nsqlookupd`实例的地址配置。不需要更改配置就可以添加新的使用者或新的发布者，从而大大降低了开销和复杂性。 

9. 注意： 未来的版本中，用于返回地址的启发式`nsqlookupd`可以基于深度、连接的客户端数量或其他“智能”策略。  当前的实现就是 `ALL`。最终的目标是确保所有生产者都是从深度接近于零的地方读取的。 

10.  需要注意的是，`nsqd`和`nsqlookupd`守护进程被设计为独立操作，没有兄弟姐妹之间的通信或协调。 

11.  我们还认为，有一种查看、内省和总体管理集群的方法是非常重要的。 

     `nsqadmin` 被用于做这件事。它提供了Web UI  浏览主题/频道/消费者的层次结构，并检查每个层的深度和其他关键统计信息 。 此外，它还支持一些管理命令，比如删除和清空通道 ( 当可以安全地丢弃通道中的消息以将深度恢复到0时，该命令是有用的 )

### Straightforward Upgrade Path

1.  这是最重要的特性之一。我们的生产系统处理大量的流量，所有这些流量都建立在现有的消息传递工具上，因此我们需要一种方法来地升级我们基础设施的特定部分，并且几乎不受影响。 

2. 步骤

   1.  首先，在消息生产者端，我们构建`nsqd`来匹配`simplequeue`。具体地说，`nsqd`公开一个`HTTP /put` endpoint，就像`simplequeue`一样，用于发布二进制数据(但有一点需要注意，endpoint需要指定一个额外的“topic”查询参数)。想要切换到开始发布到nsqd的服务只需要对代码做一些小的修改。 

   2.  其次，我们用Python和Go构建了与我们在现有库中习惯的功能和习惯用法相匹配的库。通过将代码更改限制为引导，这简化了消息使用者方面的转换。所有业务逻辑保持不变 

   3.  最后，我们构建了一些实用程序来将新旧组件粘合在一起。这些都可以在库中的示例目录中找到: 

      - `nsq_pubsub` - expose a `pubsub` like HTTP interface to topics in an **NSQ** cluster

      - `nsq_to_file` - durably write all messages for a given topic to a file

      - `nsq_to_http` - perform HTTP requests for all messages in a topic to (multiple) endpoints

###  Eliminating SPOFs 

1. NSQ被设计成以分布式方式使用。nsqd客户端(通过TCP)连接到提供指定主题的所有实例。没有中间人，没有消息代理，也没有SPOFs![tumblr_mat85kr5td1qj3yp2](F:\PersonPorject\book-notes\NSQ\img\tumblr_mat85kr5td1qj3yp2.png)
2.   This topology eliminates the need to chain single, aggregated, feeds.  而是直接从**所有**生产者那里消费。从技术上讲，无论哪个客户端连接到哪个NSQ，只要有足够多的客户端连接到所有生产者以满足消息量，就可以保证所有这些最终都会被处理。 
3.  对于`nsqlookupd`，高可用性是通过运行多个实例实现的。  它们之间不直接通信，数据最终被认为是一致的。 使用者轮询所有已配置的nsqlookupd实例，并合并响应。 过时，无法访问或其他故障的节点不会使系统陷入瘫痪。

### Message Delivery Guarantees

1.  NSQ保证一个消息将被传递至少一次，尽管重复的消息是可能的。消费者应该预料到这一点并进行反欺骗或执行幂等操作。 
2.  此保证作为协议的一部分执行，工作如下(假设客户端已成功连接并订阅了主题): 
   1.  客户端表明他们已经准备好接收消息 
   2.  NSQ发送消息并临时在本地存储数据(在重新排队或超时的情况下) 
   3.  客户端回复FIN(完成)或REQ(重新排队)，表示成功或失败。如果客户端没有回复，NSQ将在配置的超时时间后超时，并且自动重新入队
3.  这确保了惟一会导致消息丢失的边缘情况是`nsqd`进程的非正常关闭。在这种情况下，内存中的任何消息(或没有刷新到磁盘的任何缓冲写)都将丢失。
4.  如果防止消息丢失是最重要的，那么即使是这种边缘情况也可以被减轻。   一种解决方案是建立冗余的`nsqd`对，让接收同一部分消息的副本的冗余(在不同的主机上)。因为您已经将消费者编写为幂等的，所以对这些消息进行两次处理不会对下游产生影响，并且允许系统在不丢失消息的情况下忍受任何单个节点故障。 
5.  结论是，NSQ提供了构建块来支持各种生产用例和可配置的持久性程度。 

### Bounded Memory Footprint

1. `nsqd` 提供了配置选项 ` --mem-queue-size `, 用于 确定对于给定队列保存在内存中的消息数量。  如果队列的深度超过此阈值，则将消息透明地写入磁盘。 这限制了给定nsqd进程的内存占用为：`mem-queue-size * #_of_channels_and_topics`

   ![tumblr_mavte17V3t1qj3yp2](F:\PersonPorject\book-notes\NSQ\img\tumblr_mavte17V3t1qj3yp2.png)

2.  而且，敏锐的观察者可能已经发现，通过将这个值设置为较低的值(如1或甚至0)，可以方便地获得更高的交付保证。  磁盘支持的队列被设计为可以解决非正常的重启带来的消息丢失问题(尽管消息可能被传递两次)。 

3.  此外，与消息传递保证相关，正常关闭(通过发送`nsqd`进程 `TERM`信号)可以安全地将当前保存在内存中、在运行中、在延迟中以及在各种内部缓冲区中的消息。 

4.  注意， `topic/channel` 名称以字符串`#ephemeral`结尾的将不会被缓冲到磁盘上，而是在传递了内存队列大小 `mem-queue-size` 之后删除消息。 这使不需要消息保证的用户可以订阅频道。 在其最后一个客户端断开连接后，这些临时通道也将消失。 对于临时主题，这意味着已创建，使用和删除了至少一个频道（通常是一个临时频道）。

### Efficiency

1. NSQ 被设计成通过`memcached-like`命令协议上通信，同时带有简单的 `size-prefixed`响应。所有消息数据都保存在核心中，包括尝试次数、时间戳等元数据。  这消除了在服务器和客户机之间来回复制数据的情况, 这是之前工具链在重新入队时的国有属性。 这也简化了客户机，因为它们不再需要负责维护消息状态。 
2.  此外，通过减少配置复杂性，` setup and development `时间也会大大减少(特别是在主题有>1消费者的情况下)。 
3.  对于数据协议，我们做了一个关键的设计决策，通过将数据推送到客户端而不是等待它被拉出，从而最大化性能和吞吐量。 (**采用的是PUSH方式**)。 这个概念，我们称之为`RDY`状态，本质上是客户端流控制的一种形式。 
4.  当客户端连接到`nsqd`并订阅通道时，它处于`RDY`状态0。  这意味着不会向客户机发送任何消息。当客户机准备接收消息时，它发送一个命令，将其RDY状态更新到某个它准备处理的数量，比如100。 不需要任何额外的命令，100条可用的消息将被推送到客户机(每次减少该客户机在服务器端`RDY`计数)。 ![tumblr_mataigNDn61qj3yp2](F:\PersonPorject\book-notes\NSQ\img\tumblr_mataigNDn61qj3yp2.png)
5.  客户端库被设计用来发送一个命令来更新`RDY`计数，当它达到可配置的` max-in-flight `的25%时(适当地分配到多个nsqd实例的连接)。 这是一个重要的性能调优选项，因为一些下游系统能够更容易地批处理消息，并从更高的` max-in-flight `中获益。 
6.  Notably, because it is both buffered *and* push based with the ability to satisfy the need for independent copies of streams (channels), we’ve produced a daemon that behaves like `simplequeue` and `pubsub` *combined* . This is powerful in terms of simplifying the topology of our systems where we would have traditionally maintained the older toolchain discussed above. 

### Go

1.  关于NSQ, Go channel(不要与NSQ channel混淆)和该语言的内置并发特性非常适合nsqd的内部工作。我们利用缓冲通道来管理内存中的消息队列，并无缝地将溢出写入磁盘。 
2.  标准库简化了网络层和客户端代码的编写。内建的内存和cpu性能分析钩子突出了优化的机会，并且只需很少的集成工作。 我们还发现在隔离状态下测试组件、使用接口进行模拟类型测试以及迭代构建功能非常容易。 

## INTERNALS

 NSQ由3个守护进程组成: 

1. `nsqd`：  接收、排队并将消息传递给客户端。 

 	2.  `nsqlookupd`： 管理拓扑信息并提供最终一致的发现服务。 
 	3.  `nsqadmin`： 用于实时监控集群(并执行各种管理任务)的web UI。 

 NSQ中的数据流被建模为流和消费者的树。主题是不同的数据流。通道是订阅给定主题的使用者的逻辑分组。 ![f1434dc8-6029-11e3-8a66-18ca4ea10aca](F:\PersonPorject\book-notes\NSQ\img\f1434dc8-6029-11e3-8a66-18ca4ea10aca.gif)

 单个nsqd可以有多个主题，每个主题可以有多个通道。  通道接收主题的所有消息的副本，支持多播风格的传递，而通道上的每个消息都分布在其订阅者之间，支持负载平衡。 

这些原语形成了一个强大的框架来表达各种简单和复杂的拓扑。
有关NSQ设计的更多信息，请参阅设计文档 [design doc](http://nsq.io/overview/design.html). 。

### Topics and Channels

1.  主题和频道是NSQ的核心原语，最好地例证了系统的设计如何无缝地转换到Go的特征。 

2. Go的channel是一种自然的表达队列的方式， 因此，NSQ topic/channel 的核心就是一个 `Message` 指针的 `buffered go-chan`。buffer的大小等于配置参数中的  `mem-queue-size `

3.  在离线读取数据之后，将消息发布到主题的行为包括: 

   1. instantiation of a `Message` struct (and allocation of the message body `[]byte`)
   2. read-lock to get the `Topic`
   3. read-lock to check for the ability to publish
   4. send on a buffered go-chan

4. 为了从主题 topic 拿到消息发送到 channels， 主题不能依赖典型的 go-chan 接收语义， 因为在go-chan上接收的多个goroutines会分发消息，而期望的最终结果是将每个消息复制到每个通道 

5.  每个 topic 维护3个主要goroutines

   1.  ` router `: 负责从传入的go-chan读取新发布的消息并将其存储在队列(内存或磁盘)中。 
   2. ` messagePump `: 负责将信息复制并推送到上面描述的信道。 
   3.  `DiskQueue`  : 负责`DiskQueue `IO 

6.  通道稍微复杂一些，但是共享了暴露单个输入和单个输出go-chan的基本目标(从内部抽象出消息可能在内存或磁盘中的事实)

   ![682fc358-5f76-11e3-9b05-3d5baba67f13](F:\PersonPorject\book-notes\NSQ\img\682fc358-5f76-11e3-9b05-3d5baba67f13.png) 

7. 此外，每个通道维护2个按时间排序的优先级队列，负责延迟和动态消息超时(以及2个相应的goroutine，用于监视它们)。 

8. 通过管理每个通道的数据结构，而不是依赖于Go运行时的全局计时器调度器，并行化得到了改进。 

9.  **Note:** Internally, the Go runtime uses a single priority queue and goroutine to manage timers. This supports (but is not limited to) the entirety of the `time` package. It normally obviates the need for a *user-land* time-ordered priority queue but it’s important to keep in mind that it’s a *single* data structure with a *single* lock, potentially impacting `GOMAXPROCS > 1` performance. See [runtime/time.go](http://golang.org/src/pkg/runtime/time.go?s=1684:1787#L83). 

### Backend / DiskQueue

1. NSQ的设计目标之一是限制内存中的消息数量。它通过DiskQueue( which owns the *third* primary goroutine for a topic or channe )透明地将消息溢出写入磁盘来实现这一点 

2. 由于内存队列只是一个go-chan，它是琐碎的路由消息到内存，如果可能的话，然后回退到磁盘: 

    ```go
    for msg := range c.incomingMsgChan {
        select {
        case c.memoryMsgChan <- msg:
        default:
            err := WriteMessageToBackend(&msgBuf, msg, c.backend)
            if err != nil {
                // ... handle errors ...
            }
        }
    }
    ```

3. NSQ也有临时主题/通道的概念。它们丢弃消息溢出(而不是写入磁盘)，并在不再有客户端订阅时消失。 这是Go接口的一个完美用例。  主题和通道的结构成员声明为后端接口，而不是具体类型。普通的主题和通道使用磁盘队列，而临时的则使用DummyBackendQueue存根，后者实现了一个无操作后端。 

### Reducing GC Pressure

1.  在任何垃圾收集环境中，您都会受到吞吐量(做有用的工作)、延迟(响应性)和常驻集大小(占用空间)之间的压力。 
2.  到Go 1.2时，GC是标记-清楚(并行)的、非分代的、非压缩的、停止-世界的，而且基本精确的。 它基本精确的，因为剩余的工作没有及时完成(它被安排在Go 1.3中)。  
3.  Go GC肯定会继续改进，但普遍的事实是:创建的垃圾越少，收集的时间就越少。 
4. 首先，了解GC在实际工作负载下的行为非常重要。为此，`nsqd`以`statsd`格式(与其他内部度量一起)发布GC统计信息。`nsqadmin`显示这些指标的图表，让您了解GC在频率和持续时间方面的影响。
5.  为了真正减少垃圾，你需要知道垃圾是在哪里产生的。Go工具链再次提供了答案: 
   1.  使用`test`包并执行`go test -benchmem`来对热代码路径进行基准测试。它分析了每个迭代的分配数量(基准测试运行可以通过benchcmp进行比较)。 
   2.  Build using `go build -gcflags -m`, which outputs the result of [escape analysis](http://en.wikipedia.org/wiki/Escape_analysis). 
6.  考虑到这一点，下面的优化对`nsqd`非常有用: 
   1. Avoid `[]byte` to `string` conversions.
   2. Re-use buffers or objects (and someday possibly [`sync.Pool`](https://groups.google.com/forum/#!topic/golang-dev/kJ_R6vYVYHU) aka [issue 4720](https://code.google.com/p/go/issues/detail?id=4720)).
   3. Pre-allocate slices (specify capacity in `make`) and always know the number and size of items over the wire.
   4. Apply sane limits to various configurable dials (such as message size).
   5. Avoid boxing (use of `interface{}`) or unnecessary wrapper types (like a `struct` for a “multiple value” go-chan).
   6. Avoid the use of `defer` in hot code paths (it allocates).

### TCP Protocol

1.  NSQ TCP协议是一个很好的例子，在这个章节中，这些GC优化概念得到了很好的利用。 

2. 主要优化的是跟 `[] byte`有关， 避免生成字符串造成GC压力

   1.  avoid the [`encoding/binary`](http://golang.org/pkg/encoding/binary/) package’s convenience [`Read()`](http://golang.org/pkg/encoding/binary/#Read) and [`Write()`](http://golang.org/pkg/encoding/binary/#Write) wrappers (and their extraneous interface lookups and conversions) and instead call the appropriate [`binary.BigEndian`](http://golang.org/pkg/encoding/binary/#ByteOrder) methods directly. 

   2.   since data read from the socket is stored as `[]byte`, rather than produce garbage by allocating `string` keys, and to avoid a copy from the slice to the backing array of the `MessageID`, the `unsafe` package is used to cast the slice directly to a `MessageID`: 

      ```go
      id := *(*nsq.MessageID)(unsafe.Pointer(&msgID))
      ```

   3.  In order to avoid `string` allocations, **nsqd** uses a [custom base 10 conversion method](https://github.com/nsqio/nsq/blob/master/internal/protocol/byte_base10.go#L9-L29) that operates directly on a `[]byte` 

### HTTP

1.  NSQ的HTTP API建立在Go的`net/http`包之上。因为它只是HTTP，所以几乎可以在任何现代编程环境中使用它，而不需要特殊的客户端库。 

2.  它的简单性掩盖了它的强大功能，因为Go的HTTP工具箱最有趣的方面之一就是它所支持的广泛的调试功能。  The [`net/http/pprof`](http://golang.org/pkg/net/http/pprof/) package integrates directly with the native HTTP server, exposing endpoints to retrieve CPU, heap, goroutine, and OS thread profiles. These can be targeted directly from the `go` tool: 

   ```go
   go tool pprof http://127.0.0.1:4151/debug/pprof/profile
   ```

3.  此外，`/stats`endpoint 以  `JSON or pretty-printed text` 形式返回大量指标，这使得管理员可以很容易地从命令行进行实时检测: 

   ```go
   watch -n 0.5 'curl -s http://127.0.0.1:4151/stats | grep -v connected'
   ```

4.  Finally, each new Go release typically brings [measurable performance gains](https://github.com/davecheney/autobench). It’s always nice when recompiling against the latest version of Go provides a free boost! 

### Dependencies

There are two main schools of thought:

1. **Vendoring**: copy dependencies at the correct revision into your application’s repo and modify your import paths to reference the local copy.
2. **Virtual Env**: list the revisions of dependencies you require and at build time, produce a pristine `GOPATH` environment containing those pinned dependencies.

### Testing

1. there was one aspect of the initial implementation that became problematic for testing: global state. 
2.  To resolve this, a `Context` struct is passed around that contains configuration metadata and a reference to the parent **nsqd**. All references to global state were replaced with this local `Context`, allowing children (topics, channels, protocol handlers, etc.) to safely access this data and making it more reliable to test. 

### Robustness

1.  在面对不断变化的网络条件或意外事件时不够健壮的系统在分布式生产环境中表现不好。 
2.  NSQ的设计和实现允许系统容忍失败，并以一致的、可预测的和不足为奇的方式运行。 
3.  总的原则是快速失败，将错误视为致命的，并提供一种方法来调试确实发生的任何问题。 
4.  但是，为了做出反应，你需要能够探测到异常情况 

### Heartbeats and Timeouts

1.  NSQ TCP协议是面向推的。连接、握手和订阅之后，消费者处于RDY状态0。当消费者准备接收消息时，它将RDY状态更新为愿意接收的消息数量。NSQ客户端库不断地在幕后管理这些，从而产生了一个流控制的消息流。 
2.  `nsqd`将定期通过连接发送一个心跳。客户端可以配置心跳之间的间隔，但是`nsqd`在发送下一个心跳之前需要一个响应。 
3.  应用程序级心跳和RDY状态的组合避免了 [head-of-line blocking](http://en.wikipedia.org/wiki/Head-of-line_blocking) ，其可能会使心跳变得无效( 也就是说，如果消费者在处理消息流时落后了，操作系统的接收缓冲区就会被填满，从而阻塞心跳 )
4.   为了保证进度，所有网络IO都与配置的心跳间隔的截止日期绑定在一起。这意味着您完全可以断开nsqd和使用者之间的网络连接，它将检测并正确处理错误。 
5.  当检测到致命错误时，将强制关闭客户端连接。正在运行的消息超时并重新排队交付给另一个使用者。最后，记录错误并增加各种内部度量。 

### Managing Goroutines

1.  启动goroutines非常简单。不幸的是，要协调他们的清理工作并不那么容易。避免死锁也是一个挑战。这通常归结为一个排序问题，即在go-chan上接收的goroutine在上游goroutine发送之前就退出了。
2.  为什么要关心这些呢?很简单，孤立的goroutine是内存泄漏。在长时间运行的守护进程中出现内存泄漏是很糟糕的，特别是当其他所有操作都失败时，需要保证您的进程应该是稳定的。 
3.  更复杂的是，一个典型的`nsqd`流程在消息传递中包含许多goroutine。在内部，消息“所有权”经常改变。为了能够干净地关闭，对所有进程内的消息负责是非常重要的。 
4.  虽然没有什么灵丹妙药，但是下面的技巧可以使它更容易管理…… 

1. WaitGroups

2. Exit Signaling

### Synchronizing Exit

### Logging





# COMPONENTS 

# CLIENTS (Lib)

# CLIENTS (TCP) 



