 [官网地址]( https://nsq.io/overview/quick_start.html )

# OVERVIEW 

## QUICK START

1. 安装NSQ， [地址]( https://nsq.io/deployment/installing.html )

2. in one shell, start `nsqlookupd`:

   ```
   $ nsqlookupd
   ```

3. in another shell, start `nsqd`:

   ```
   $ nsqd --lookupd-tcp-address=127.0.0.1:4160
   ```

4. in another shell, start `nsqadmin`:

   ```
   $ nsqadmin --lookupd-http-address=127.0.0.1:4161
   ```

5. publish an initial message (creates the topic in the cluster, too):

   ```
   $ curl -d 'hello world 1' 'http://127.0.0.1:4151/pub?topic=test'
   ```

6. finally, in another shell, start `nsq_to_file`:

   ```
   $ nsq_to_file --topic=test --output-dir=/tmp --lookupd-http-address=127.0.0.1:4161
   ```

7. publish more messages to `nsqd`:

   ```
   $ curl -d 'hello world 2' 'http://127.0.0.1:4151/pub?topic=test'
   $ curl -d 'hello world 3' 'http://127.0.0.1:4151/pub?topic=test'
   ```

8. to verify things worked as expected, in a web browser open `http://127.0.0.1:4171/` to view the `nsqadmin` UI and see statistics. Also, check the contents of the log files (`test.*.log`) written to `/tmp`.

## FEATURES & GUARANTEES

 NSQ是一个实时分布式消息传递平台

1. Features

   1.  支持没有SPOF (Single Point Of Failure, 单点故障) 的分布式拓扑 
   2.  水平扩展 (没有brokers ，无缝地向集群添加更多节点) 
   3. 基于消息传递的低延迟push
   4.  组合负载平衡和多播样式的消息路由 
   5.  擅长面向流(高吞吐量)和面向job(低吞吐量)的工作负载 
   6.  主要在内存中(高水位标记之外的消息透明地保存在磁盘上) 
   7.  运行时发现服务，供消费者者查找生产者([nsqlookupd](https://github.com/nsqio/nsq/tree/master/nsqlookupd/README.md) ) 
   8.  传输层安全性(TLS) 
   9.  data format agnostic 
   10.  很少的依赖项(易于部署)和一个健全的、有限的默认配置
   11.  简单的TCP协议支持任何语言的客户端库 
   12. 用于统计、管理操作和生产者的HTTP接口(发布消息不需要客户端库)  
   13.  与``statsd`集成，实现实时检测 
   14.  健壮的集群管理接口(nsqadmin) 

2. ### Guarantees

   1.  消息**不是**持久的(默认情况下) 
   2.  消息至少传递一次 
   3.  接收到的消息是无序的 
   4.  消费者**最终**会找到所有的主题生产者 

3. FAQ

   1. #### Deployment

      1.  nsqd的推荐拓扑是什么?
      2.  为什么`nsqlookupd`不能被生产者用来查找发布到哪里? 
      3.   我只想使用`nsqd`作为单个节点上的工作队列，这是一个合适的使用场景吗? 
      4.   我应该运行多少个nsqlookupd ? 
      
   2. #### Publishing
   
      1.  我需要一个客户端库来发布消息吗? 
   
      2.  为什么要强制客户端处理对TCP协议的PUB和MPUB命令的响应? 
   
      3.  When can a `PUB` or `MPUB` fail? 
   
         1. The topic name is not formatted correctly (to character/length restrictions). See the [topic and channel name spec](https://nsq.io/clients/tcp_protocol_spec.html#notes).
         2. The message is too large (this limit is exposed as a parameter to `nsqd`).
         3. The topic is in the middle of being deleted.
         4. `nsqd` is in the middle of cleanly exiting.
         5. Any client connection-related failures during the publish.
   
         (1) and (2) should be considered programming errors. (3) and (4) are rare and (5) is a natural part of any TCP based protocol.
   
      4.  How can I mitigate scenario (3) above?
   
   3. #### Design and Theory
   
      1.  如何为主题和通道命名? 
   
         1. A topic name should describe the *data in the stream*.
         2. A channel name should describe the *work performed* by its consumers.
         3. For example, good topic names are `encodes`, `decodes`, `api_requests`, `page_views` and good channel names are `archive`, `analytics_increment`, `spam_analysis`.
   
      2.  单个nsqd可以支持的主题和通道的数量有限制吗? 
   
          没有内置的限制。它只受运行nsqd的主机的内存和CPU的限制 
   
      3.  如何向集群发布/t通告新主题?
   
          第一个`PUB`或`SUB`将在nsqd上创建主题。然后，主题元数据将传播到配置的`nsqlookupd`。其他读者将通过定期查询`nsqlookupd`来发现这个主题。  
   
      4.  NSQ可以做RPC吗? 
   
   4. 
   
   5. #### pynsq Specific