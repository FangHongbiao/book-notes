### 锁
1. 实现一个锁
2. 评价锁
   1. 是否能够完成基本任务, 即互斥
   2. 公平性
   3. 性能
      1. 无竞争
      2. 单CPU上竞争
      3. 多CPU上竞争
3. 基于硬件实现锁
   1. 控制中断
      1. 进入临界区之前关闭中断, 结束之后打开中断. 保证临界区代码不会被中断, 从而原子执行
      2. 优点: 实现简单, 原理简单
      3. 缺点
         1. 要求允许所有调用线程执行特权操作, 即信任这种机制不会被滥用
         2. 不支持多处理器
         3. 关闭中断导致中断丢失, 可能导致严重的系统问题
         4. 效率太低. 与正常指令执行相比, 现代CPU待遇打开和关闭中断的代码执行得较慢
   2. 测试并设置指令(原子交换)
      1. 测试并设置指令(test-and-set instruction) 或者 原子交换(atomic exchange)
      2. 不是使用原子操作实现锁存在并发不一致问题
      3. 使用原子交换操作实现锁
      ```C
      typedef struct lock_t {
          int flag;
      } lock_t;

      void init(lock_t *lock) {
          lock->flag = 0;
      }

      void lock(lock_t *lock) {
          while (TestAndSet(&lock->flag, 1) == 1) {
              // spin-wait (do nothing)
          }
      }

      void unlock(lock_t *lock) {
           lock->flag = 0;
      }
      ```
      4. 分析上述方案为什么能实现锁语义
         1. flag 是 0
         2. flag 是 1
      5. 自旋锁的要求
         1. 在单处理器上, 需要抢占式的调度器, 否则, 自旋锁在但CPU上无法使用, 因为一个自旋的线程永远不会放弃CPU
      6. 评价自旋锁
         1. 提供基本的互斥功能
         2. 不支持公平性, 有可能饿死
         3. 性能
            1. 但CPU情况下, 性能开销相当大
            2. 多CPU上, 自旋锁性能不错(如果线程数大于等于CPU数)
   3. 比较并交换(CAS)
      1. 与Test-And-Set的区别: 给了一个预期值expect value
      2. 返回的是内存地址实际的(旧)值
      3. 使用CAS实现锁
      ```C
       typedef struct lock_t {
           int flag;
       } lock_t;
       
       void init(lock_t *lock) {
           lock->flag = 0;
       }

       void lock(lock_t *lock) {
           while (CompareAndSwap(&lock->flag, 0, 1) == 1) {
               // spin-wait (do nothing)
           }
       }

       void unlock(lock_t *lock) {
           lock->flag = 0;
       }
      ```
   4. 链接的加载和条件式存储指令
      1. 一些平台提供了实现临界区的一对指令. 例如 MIPS架构中, 链接的加载(load-linked) 和 条件式存储(store-conditional) 可以用来配合使用, 实现其他并发结构.
      2. 实现锁
      ```C
      void lock(lock_t *lock) {
          while (1) {
              while (LoadLinked(&lock-flag) == 1) {
                  // spin until it's zero
              }

              if (StoreConditional(&lock->flag, 1) == 1) {
                  return;
              }
          }
      }
      ```
    5. 获取并增加
       1. fetch-and-add指令, 能原子地返回特定地址的旧值, 并且让该值自增1.
       2. 基于fetch-and-add实现ticket锁
       ```C
       int FetchAndAdd(int *ptr) {
           int old = *ptr;
           *ptr = old + 1;
           return old;
       }

       typedef struct lock_t {
           int ticket;
           int turn;
       } lock_t;

       void lock_init(lock_t * lock) {
           lock->ticket = 0;
           lock->turn = 0;
       }

       void lock(lock_t *lock) {
           int myturn = FetchAndAdd(&lock->ticket);
           while(lock->turn != myturn) {
               //spin
           }
       }

       void unlock(lock_t *lock) {
           FetchAndAdd(&lock->turn);
       }
       ```
       4. 公平锁, 该方法能够保证所有线程都能抢到锁. 只要一个线程获得了ticket值, 就一定会被最终被调度. 而前面的方法都不会保证
4. 解决自旋过多带来的CPU资源消耗问题
   1. 使用yield
   ```C
   void init() {
       flag = 0;
   }

   void lock() {
       while(TestAndSet(&flag, 1) == 1) {
           yield;
       }
   }

   void unlock() {
       flag = 0;
    }
   ``` 
   1. 使用队列: 休眠代替自旋
   2. 两阶段锁: 若干次自旋 + 阻塞锁 \
   *yield 和 park的区别*